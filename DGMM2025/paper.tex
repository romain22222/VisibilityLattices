% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%\documentclass[draft]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
\usepackage{hyperref}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{environ}
\usepackage{bbm}

\usepackage{changes}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{varwidth}
\usepackage{mathtools}
\usepackage{pgfplots}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\pgfplotsset{compat=1.18}
\usetikzlibrary {spy,arrows.meta,decorations.shapes}
\setauthormarkup{}
\definechangesauthor[name=jo, color=blue]{JO}
\definechangesauthor[name=rom, color=teal]{ROM}

\input{./macros}

%
\begin{document}
%
    \title{Fast and exact visibility on digitized shapes and application to saliency-aware normal estimation}
%
    \titlerunning{Fast and exact visibility on digitized shapes}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
    \author{Romain Negro\inst{1}\orcidID{0000-XXXX-YYYY-ZZZZ} \and
    Jacques-Olivier Lachaud\inst{1}\orcidID{0000-0003-4236-2133}}
%
    \authorrunning{R. Negro and J.-O. Lachaud}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
    \institute{Universit\'e Savoie Mont Blanc, CNRS, LAMA, F-73000 Chamb√©ry, France\\
    \email{\{romain.negro|jacques-olivier.lachaud\}@univ-smb.fr}}
%
    \maketitle              % typeset the header of the contribution
%
    \begin{abstract}
        Computing visibility on a geometric object requires heavy
        computations since it requires to identify pairs of points that
        are visible to each other, i.e.\ there is a straight segment
        joining them that stays in the close vicinity of the object
        boundary. We propose to exploit a specific representation of
        digital sets based on lists of integral intervals in order to
        compute efficiently the complete visibility graph between
        lattice points of the digital shape. As a quite direct
        application, we show then how we can use visibility to estimate
        the normal vector field of a digital shape in an accurate and
        convergent manner while staying aware of the salient and sharp features of
        the shape.

        \keywords{Visibility \and Geometric inference \and Digital normal estimation \and Digital geometry}
    \end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \section{Introduction}
    \input{introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \section{Visibility through tangency of chords}
    \input{visibility}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \section{Fast computation using integer intervals intersections}

    To improve computation time, we will use lattice maps of integer intervals.

    \begin{definition}
        A sequence of intervals is an ordered list of intervals $L = ([a_i,b_i])_{i=1,\ldots,n}$ such that $b_i + 1 < a_{i+1}$, i.e., disjoint intervals with at least a missing integer.
    \end{definition}

    \begin{definition}
        A translation of an interval $A$ is defined as $A+t \coloneqq [a+t, b+t]$
    \end{definition}

    \begin{definition}
        A translation of a sequence of intervals $L$ is the sequence defined as $L+t \coloneqq \{L_1+t,\ldots,L_n+t\}$
    \end{definition}

    \begin{definition}
        All translations $T$ of an interval or a sequence of intervals $A$ in a sequence of intervals $L$ are defined as $ T \coloneqq \{ t, st. A+t \subset L\}$
    \end{definition}

    We will consider lattice maps as pairs of (shift, intervals), where shifts are points $p \in \R^{d-1}$. All coordinates are doubled, so that the represented cell $\forall c \in \R^d$ will have a dimension equal to $\sum_{i=1}^d \left(c[i]\mod d\right)$.
    In figure~\ref{fig:lattice-representation}, we display a representation of lattice maps applied to a 2-d cell complex where all coordinates are already doubled. Note that the examples are in 2-d, the shown results are in 3-d and the algorithm is for n-d.

    \begin{figure}
        \centering
        \label{fig:lattice-representation}
        % \usetikzlibrary {arrows.meta,decorations.shapes}
        \begin{tabular}{c c}
            \begin{tikzpicture}[scale=0.75]
                \draw[step=0.5,lightgray,thin,xshift=-1cm,yshift=-1cm] (-0.25,-0.25) grid (7.25,7.25);
                \filldraw[black] (1,4) circle (0.05);
                \filldraw[black] (1,5) circle (0.05);
                \filldraw[black] (2,5) circle (0.05);
                \filldraw[black] (3,5) circle (0.05);
                \filldraw[black] (3,4) circle (0.05);
                \filldraw[black] (3,3) circle (0.05);
                \filldraw[black] (3,2) circle (0.05);
                \filldraw[black] (2,2) circle (0.05);
                \filldraw[black] (2,1) circle (0.05);
                \filldraw[black] (1,1) circle (0.05);
                \filldraw[black] (1,0) circle (0.05);
                \filldraw[black] (2,0) circle (0.05);
                \filldraw[black] (3,0) circle (0.05);
                \filldraw[black] (3,1) circle (0.05);
                \filldraw[black] (4,1) circle (0.05);
                \filldraw[black] (5,1) circle (0.05);
                \draw[-{Stealth[length=3mm]}=black] (-1,-1) -- (-1,6.5);
                \draw decorate [decoration={crosses,transform={rotate=45},shape size=1.5mm,segment length=21.5pt}] {(-1,-1) -- (-1,7)};
                \draw[black] (1,4) -- (1,5) -- (3,5) -- (3,2) -- (2,2) -- (2,1) -- (1,1) -- (1,0) -- (3,0) -- (3,1) -- (5,1);
                \draw[thick,dashed] (1,3) -- (1,2) -- (0,2) -- (0,-1) -- (4,-1) -- (4,0) -- (6,0) -- (6,2) -- (4,2) -- (4,6) -- (0,6) -- (0,3) -- (2,3) -- (2,4);
            \end{tikzpicture} &
            %      \begin{tikzpicture}
            %     \foreach \y in {1,1.5,...,6} {
            %       \draw[thin, lightgray,xshift=-1cm,yshift=-1cm] (0.75,\y) -- (6.25,\y);
            %     }
            %     \draw[-{Stealth[length=3mm]}=black] (0,0) -- (0,5.5);
            %     \draw decorate [decoration={crosses,transform={rotate=45},shape size=1.5mm,segment length=10mm}] {(0,0) -- (0,5)};
            %     \draw[black] (1,4) -- (1,5) -- (3,5) -- (3,2) -- (2,2) -- (2,1) -- (1,1) -- (1,0) -- (3,0) -- (3,1) -- (5,1);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.9,5)--(3.1,5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.9,4.5)--(1.1,4.5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.9,4.5)--(3.1,4.5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.9,4)--(1.1,4);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.9,4)--(3.1,4);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.9,3.5)--(3.1,3.5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.9,3)--(3.1,3);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.9,2.5)--(3.1,2.5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.9,2)--(3.1,2);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.9,1.5)--(2.1,1.5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.9,1)--(2.1,1);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.9,1)--(5.1,1);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.9,0.5)--(1.1,0.5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.9,0.5)--(3.1,0.5);
            %     \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.9,0)--(3.1,0);
            %     \filldraw[white,yshift=-1cm] (0,0) circle (0.01); % readjust the height to match the original path
            % \end{tikzpicture} &
            \begin{tikzpicture}[scale=0.75]
                \foreach \y in {0,0.5,...,7} {
                    \draw[thin, lightgray,xshift=-1cm,yshift=-1cm] (-0.25,\y) -- (7.25,\y);
                }
                \draw[-{Stealth[length=3mm]}=black] (-1,-1) -- (-1,6.5);
                \draw decorate [decoration={crosses,transform={rotate=45},shape size=1.5mm,segment length=21.5pt}] {(-1,-1) -- (-1,6.5)};
                \draw[thick,dashed] (1,3) -- (1,2) -- (0,2) -- (0,-1) -- (4,-1) -- (4,0) -- (6,0) -- (6,2) -- (4,2) -- (4,6) -- (0,6) -- (0,3) -- (2,3) -- (2,4);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,5.5)--(3.6,5.5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,5)--(3.6,5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,4.5)--(3.6,4.5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,4)--(1.6,4);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.4,4)--(3.6,4);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,3.5)--(1.6,3.5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.4,3.5)--(3.6,3.5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (2.4,3)--(3.6,3);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,2.5)--(3.6,2.5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,2)--(3.6,2);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,1.5)--(5.6,1.5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,1)--(5.6,1);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,0.5)--(5.6,0.5);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,0)--(3.6,0);
                \draw[thick, arrows = {Bracket[sharp]-Bracket[sharp]}] (0.4,-0.5)--(3.6,-0.5);
                \filldraw[white,yshift=-1.25cm] (0,0) circle (0.01); % readjust the height to match the original path
            \end{tikzpicture}
        \end{tabular}
        \caption{Representation of a 2d cell complex (here the star of a given curve) as a lattice map. From 31 cells from the star on the left, we get 15 intervals on the right}
    \end{figure}

    \colorlet{MyGreen}{green!80!gray}
    \begin{figure}
        \centering
        \begin{tabular}{c c}
            \begin{tikzpicture}[scale=0.75]
                \foreach[count=\i] \y in {-0.5,0,...,1.5} {
                    \draw (0,0) node at (-1.25,\y) {\i};
                }
                \draw[step=0.5,lightgray,thin,xshift=-1cm,yshift=-1cm] (-0.75,-0.25) grid (12.25,3.25);
                \draw[-{Stealth[length=3mm]}=black] (-1.5,-1) -- (-1.5,2.5);
                \filldraw[black] (0,0) circle (0.05);
                \filldraw[black] (1,0) circle (0.05);
                \filldraw[black] (2,0) circle (0.05);
                \filldraw[black] (2,1) circle (0.05);
                \filldraw[black] (3,1) circle (0.05);
                \filldraw[black] (4,1) circle (0.05);
                \filldraw[black] (5,1) circle (0.05);
                \filldraw[black] (5,0) circle (0.05);
                \filldraw[black] (6,0) circle (0.05);
                \filldraw[black] (7,0) circle (0.05);
                \filldraw[black] (7,1) circle (0.05);
                \filldraw[black] (8,1) circle (0.05);
                \filldraw[black] (8,0) circle (0.05);
                \filldraw[black] (9,0) circle (0.05);
                \filldraw[black] (10,0) circle (0.05);
                \filldraw[black] (10,1) circle (0.05);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,-0.5)--(2.6,-0.5);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,-0.5)--(10.6,-0.5);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,0)--(2.6,0);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,0)--(10.6,0);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,0.5)--(10.6,0.5);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,1)--(5.6,1);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (6.4,1)--(8.6,1);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (9.4,1)--(10.6,1);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,1.5)--(5.6,1.5);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (6.4,1.5)--(8.6,1.5);
                \draw[thick,gray, arrows = {Bracket[sharp]-Bracket[sharp]}] (9.4,1.5)--(10.6,1.5);
                \draw[thick, black] (0,0) -- (2,0) -- (2,1) -- (5,1) -- (5,0) -- (7,0) -- (7,1) -- (8,1) -- (8,0) -- (10,0) -- (10,1);
                \draw[thick,dashed] (6,1) -- (6,2);
                \draw[thick,dashed] (9,1) -- (9,2);
                \draw[thick,dashed] (-1,-1) -- (-1,1) -- (1,1) -- (1,2) -- (11,2) -- (11,-1) -- (4,-1) -- (4,0) -- (3,0) -- (3,-1) -- (-1,-1);

                \draw (0,0) node at (-0.25,1.75) {F};

                \draw[red,arrows = {-Stealth[]}] (0,0)--(2,1);
                \draw[red,arrows = {-Stealth[]}] (1,0)--(3,1);
                \draw[red,arrows = {-Stealth[]}] (2,0)--(4,1);
                \draw[red,arrows = {-Stealth[]}] (5,0)--(7,1);
                \draw[red,arrows = {-Stealth[]}] (6,0)--(8,1);
                \draw[red,arrows = {-Stealth[]}] (8,0)--(10,1);


            \end{tikzpicture} &
            \begin{tikzpicture}[scale=0.75]
                \draw[step=0.5,lightgray,thin,xshift=-1cm,yshift=-1cm] (-0.75,-0.25) grid (4.25,3.25);
                \draw[-{Stealth[length=3mm]}=black] (-1.5,-1) -- (-1.5,2.5);
                \foreach[count=\i] \y in {-0.5,0,...,1.5} {
                    \draw (0,0) node at (-1.25,\y) {\i};
                }
                \filldraw[black] (0,0) circle (0.05);
                \filldraw[black] (2,1) circle (0.05);
                \draw[thick, black] (0,0) -- (2,1);
                \draw[thick,dashed] (-1,-1) -- (-1,1) -- (1,1) -- (1,2) -- (3,2) -- (3,0) -- (1,0) --  (1,-1) -- (-1,-1);
                \draw[thick,MyGreen, arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,-0.5)--(0.6,-0.5);
                \draw[thick,MyGreen, arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,0)--(0.6,0);
                \draw[thick,MyGreen, arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,0.5)--(2.6,0.5);
                \draw[thick,MyGreen, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,1)--(2.6,1);
                \draw[thick,MyGreen, arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,1.5)--(2.6,1.5);

                \draw (0,0) node at (-0.25,1.75) {V};
            \end{tikzpicture} \\
            \hline
            \multicolumn{2}{c}{
                \begin{tikzpicture}[scale=0.75]
                    \foreach \y in {0,0.5,...,12.5} {
                        \draw[thin, lightgray] (-1.25,\y) -- (11.25,\y);
                    }
                    \foreach \y in {0,2.5,...,12.5} {
                        \draw[blue] (-7,\y) -- (11.25,\y);
                    }

                    \foreach[count=\i] \y in {12,9.5,...,2} {
                        \draw (0,0) node at (-4,\y) {$V_{\i}$};
                    }
                    \foreach[count=\i] \y in {11.5,9,...,1.5} {
                        \draw (0,0) node at (-4,\y) {$F_{\i}$};
                    }
                    \draw (0,0) node at (-4,11) {$T_{1} = \text{Translations}(V_{1},F_{1})$};
                    \foreach[count=\i] \y in {8.5,6,...,1} {
                        \draw (0,0) node at (-4,\y) {$T_{\the\numexpr\i+1\relax}$};
                    }
                    \draw (0,0) node at (-4,10.5) {$R_1 = T_1$};

                    \foreach[count=\i] \y in {8,5.5,...,0.5} {

                        \draw (0,0) node at (-4,\y) {$R_{\the\numexpr\i+1\relax} = T_{\the\numexpr\i+1\relax} \cap R_{\i}$};
                    }

                    \draw[thick,MyGreen,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,12)--(0.6,12);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,11.5)--(2.6,11.5);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,11.5)--(10.6,11.5);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,11)--(1.6,11);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,11)--(9.6,11);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,10.5)--(1.6,10.5);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,10.5)--(9.6,10.5);
                    \filldraw[black] (-0.5,10.5) circle (0.05);
                    \filldraw[black] (0.5,10.5) circle (0.05);
                    \filldraw[black] (1.5,10.5) circle (0.05);
                    \filldraw[black] (4.5,10.5) circle (0.05);
                    \filldraw[black] (5.5,10.5) circle (0.05);
                    \filldraw[black] (6.5,10.5) circle (0.05);
                    \filldraw[black] (7.5,10.5) circle (0.05);
                    \filldraw[black] (8.5,10.5) circle (0.05);
                    \filldraw[black] (9.5,10.5) circle (0.05);


                    \draw[thick,MyGreen,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,9.5)--(0.6,9.5);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,9)--(2.6,9);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,9)--(10.6,9);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,8.5)--(1.6,8.5);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,8.5)--(9.6,8.5);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,8)--(1.6,8);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,8)--(9.6,8);
                    \filldraw[black] (-0.5,8) circle (0.05);
                    \filldraw[black] (0.5,8) circle (0.05);
                    \filldraw[black] (1.5,8) circle (0.05);
                    \filldraw[black] (4.5,8) circle (0.05);
                    \filldraw[black] (5.5,8) circle (0.05);
                    \filldraw[black] (6.5,8) circle (0.05);
                    \filldraw[black] (7.5,8) circle (0.05);
                    \filldraw[black] (8.5,8) circle (0.05);
                    \filldraw[black] (9.5,8) circle (0.05);

                    \draw[thick,MyGreen,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,7)--(2.6,7);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,6.5)--(10.6,6.5);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,6)--(7.6,6);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,5.5)--(1.6,5.5);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,5.5)--(7.6,5.5);
                    \filldraw[black] (-0.5,5.5) circle (0.05);
                    \filldraw[black] (0.5,5.5) circle (0.05);
                    \filldraw[black] (1.5,5.5) circle (0.05);
                    \filldraw[black] (4.5,5.5) circle (0.05);
                    \filldraw[black] (5.5,5.5) circle (0.05);
                    \filldraw[black] (6.5,5.5) circle (0.05);
                    \filldraw[black] (7.5,5.5) circle (0.05);

                    \draw[thick,black,arrows = {-Stealth[]}] (-0.6,4.5)--(1.4,4.5);
                    \draw[thick,MyGreen,arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,4.5)--(2.6,4.5);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,4)--(5.6,4);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (6.4,4)--(8.6,4);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (9.4,4)--(10.6,4);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,3.5)--(2.6,3.5);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,3.5)--(5.6,3.5);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (7.4,3.5)--(7.6,3.5);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,3)--(1.6,3);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,3)--(5.6,3);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (7.4,3)--(7.6,3);
                    \filldraw[black] (-0.5,3) circle (0.05);
                    \filldraw[black] (0.5,3) circle (0.05);
                    \filldraw[black] (1.5,3) circle (0.05);
                    \filldraw[black] (4.5,3) circle (0.05);
                    \filldraw[black] (5.5,3) circle (0.05);
                    \filldraw[black] (7.5,3) circle (0.05);

                    \draw[thick,black,arrows = {-Stealth[]}] (-0.6,2)--(1.4,2);
                    \draw[thick,MyGreen,arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,2)--(2.6,2);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (1.4,1.5)--(5.6,1.5);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (6.4,1.5)--(8.6,1.5);
                    \draw[thick,gray,arrows = {Bracket[sharp]-Bracket[sharp]}] (9.4,1.5)--(10.6,1.5);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,1)--(2.6,1);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,1)--(5.6,1);
                    \draw[thick,violet,arrows = {Bracket[sharp]-Bracket[sharp]}] (7.4,1)--(7.6,1);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (-0.6,0.5)--(1.6,0.5);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (4.4,0.5)--(5.6,0.5);
                    \draw[thick,red,arrows = {Bracket[sharp]-Bracket[sharp]}] (7.4,0.5)--(7.6,0.5);
                    \filldraw[black] (-0.5,0.5) circle (0.05);
                    \filldraw[black] (0.5,0.5) circle (0.05);
                    \filldraw[black] (1.5,0.5) circle (0.05);
                    \filldraw[black] (4.5,0.5) circle (0.05);
                    \filldraw[black] (5.5,0.5) circle (0.05);
                    \filldraw[black] (7.5,0.5) circle (0.05);

                \end{tikzpicture}}
        \end{tabular}
        \caption{Evolution of the visibility check algorithm for a 2,1 vector. Green is the vector lattice map, black is the figure lattice map, red are the current intervals of positions where the visibility is still possible. The last red intervals are the visible positions. We travel the lattice maps from bottom-up. The found possible visibilities are shown on the original figure}
        \label{fig:visibility-algorithm-evolution}
    \end{figure}

    \begin{algorithm}
        \caption{Given a cell complex C and a radius $r$, compute the visibility at every point of C up to distance $r$. We assume z being the main axis of the lattice maps, x and y being the auxiliary axises}
        \label{alg:visibility}
        \begin{algorithmic}
            \Function{Visibility}{C: Cell complex, r: Integer}
                \State $\Omega \gets \Call{Star}{C}$ \Comment{Lattice map of the star of the studied cell complex}
                \State $Directions \gets \Call{GetAllPrimalDirections}{r}$
                \State $V: \text{vector of boolean} \gets [0, \ldots, 0]$ \Comment{length $Size(Directions) \times \#C.pointels$}
                \State $low, high \gets \Call{BoundingBoxZ}{\Omega}$
                \ForAll{$d$ in $Directions$}
                    \ForAll{shift $S$ in $\Omega$}
                        \State $R \gets [low, high]$
                        \ForAll{pair $P$ in $\Call{Star}{\text{d}}$}
                            \State $R \gets R \cap \Call{Translations}{P.intervals,\Omega[S + P.shift]}$
                        \EndFor
                        \State \Call{UpdateVisibility}{$V$, $R$}
                    \EndFor
                \EndFor
                \State \Return $V$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    In order to compute the visibility, we first compute $\Omega = \text{Star}(C)$. Then for each primal direction of
    coordinates at most $r$, we look at all the possible positions this specific direction does link 2 visible points
    of the cell complex. In order to do so, for each shift in $\Omega$, we compute the positions where points are
    visible using the same method as presented in~\ref{fig:visibility-algorithm-evolution}. Some results of visible
    points are present in figure~\ref{fig:visibility-results}.

    \begin{algorithm}
        \caption{Given 2 lists of intervals $K$ and $L$, find $K \cap L$, the intersection of those 2 lists}
        \label{alg:intersection}
        \begin{algorithmic}
            \Function{Intersection ($\cap$)}{\text{K, L}: Intervals}
                \State $R \gets \emptyset$; $k, l \gets 0$
                \While{$k < K.nbIntervals \And l < L.nbIntervals$}
                    \State $[a,b] \gets K[k]$; $[c,d] \gets L[l]$
                    \State $e \gets \max(a, c)$; $f \gets \min(b, d)$
                    \If{$e \leq f$}
                        \State $R.append([e, f])$
                    \EndIf
                    \If{$b \leq d$}
                        \State $k \gets k+1$
                    \EndIf
                    \If{$d \leq b$}
                        \State $l \gets l+1$
                    \EndIf
                \EndWhile
                \State \Return $R$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    To efficiently compute the intersection of 2 lists of intervals $K$ and $L$, we go through the first 2 unvisited
    elements of the 2 lists. If they don't overlap (i.e.\ the start and end of the 1st interval are both smaller than
    the start of the other), then we can discard the smaller interval. Else, we construct the intersection of these
    2 intervals as one of the resulting intervals. We then can skip the interval with the smallest end. If both
    intervals have the same end, then both intervals can be skipped. Doing this computation until one of the lists
    is empty returns the intersection of both lists of intervals.

    % Insert visibility results images

    \begin{figure}
        \centering
        \begin{tabular}{c c}
            \includegraphics[width=0.4\textwidth]{pictures/visibility_from_given_point_r_10} &
            \includegraphics[width=0.4\textwidth]{pictures/visibility_aware_of_features}
        \end{tabular}
        \caption{Examples of visibility on a fandisk and a torus knot. First one is on the edge
        of a fandisk, where the visibility stops at the edges. The other one is in the interior
        of a torus knot, where we can see that the visibility is feature-aware and doesn't see
        the other side of the torus' branch.}
        \label{fig:visibility-results}
    \end{figure}
%
%    \begin{figure}
%        \begin{center}
%            \includegraphics[width=0.8\textwidth]{pictures/visibility_from_given_point_r_10}
%            \caption{Visibility of a point on an edge of a fandisk}
%            \label{fig:visibility-fandisk}
%        \end{center}
%    \end{figure}
%    \begin{figure}
%        \begin{center}
%            \includegraphics[width=0.8\textwidth]{pictures/visibility_aware_of_features}
%            \caption{Visibility of a point on a torus knot (the visibility is feature-aware)}
%            \label{fig:visibility-torus-knot}
%        \end{center}
%    \end{figure}


    % Quantitative results

    \begin{figure}
        \begin{tikzpicture}
            \centering
            \begin{axis}[
                width=0.8\textwidth,
                legend columns=3,
                xlabel={Gridstep},
                ylabel={Mean distance},
                x dir=reverse,
                legend pos=north west,
                ymajorgrids=true,
                grid style=dashed,
                ymax=70,
                ymode=log,
                xmode=log,
                log ticks with fixed point,
            ]

                \addplot[
                    color=cyan,
                ] coordinates {
                    (0.0625,7.61948)(0.125,5.49755)(0.25,3.97418)(0.375,3.00921)(0.5,2.85702)(0.625,2.34448)(0.75,1.85023)(0.875,2.16868)(1.0,1.85023)
                };
                \addlegendentry{sphere1}
                \addplot[
                    color=red,
                ] coordinates {
                    (0.0625,38.1045)(0.125,26.8765)(0.25,19.6747)(0.375,16.6192)(0.5,14.0867)(0.625,12.5062)(0.75,11.3734)(0.875,10.2845)(1,8.90781)
                };
                \addlegendentry{goursat}
                \addplot[
                    color=violet,
                ] coordinates {
                    (0.0625,25.5024)(0.125,18.2364)(0.25,12.3975)(0.375,9.41303)(0.5,8.69558)(0.625,7.37667)(0.75,6.82131)(0.875,6.05735)(1,6.33877)
                };
                \addlegendentry{torus}
                \addplot[
                    color=MyGreen,
                ] coordinates {
                    (0.0625,27.9287)(0.125,17.5104)(0.25,10.8007)(0.375,8.69514)(0.5,7.26074)(0.625,6.2309)(0.75,5.6897)(0.875,5.28197)(1,4.96098)
                };
                \addlegendentry{leopold}
                \addplot[
                    color=yellow!80!black,
                ] coordinates {
                    (0.0625,41.9816)(0.125,27.7104)(0.25,18.2339)(0.375,14.6475)(0.5,12.3618)(0.625,9.55647)(0.75,9.83208)(0.875,7.51861)(1,7.99732)
                };
                \addlegendentry{rcube}
                \addplot [
                    color=black,
                    thick,
                    domain=0.0625:1,
                    samples=100,
                ] {x^(-0.5)};
                \addlegendentry{$\sqrt{h}=\sqrt{\frac{1}{x}}$}
            \end{axis}
        \end{tikzpicture}
        \caption{Mean Visibility Distance as a Function of Grid Resolution}
        \label{fig:meanvisibility-gridstep}
    \end{figure}

    \begin{figure}[t]
        \input{pointelscomptime.tikz}
        \caption{Computation Time of Visibility as a Function of pointels amount. We compare the computation time of
        the naive breadth first visibility algorithm against our version using intervals. We input the same radius to
        both versions (10, 20, 30) and test it on 6 different figures (goursat, torus, rcube, sphere9, leopold, d20)
        with various gridsteps, giving us figures with pointel amounts ranging from 520 to 390235.}
        \label{fig:meanvisibility-computationComplexity}
    \end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \section{Saliency-aware normal and curvature estimation}

    \newcommand{\Kernel}[1]{\ensuremath{w_{\sigma}(#1)}}

    \paragraph{Saliency-aware normal estimator.}
    We propose a new normal estimator on digital surfaces, which uses
    the visibility of the point of interest while taking into account
    a user-given scale $\sigma$. If $\sigma$ is proportionnal to the
    average length between visible points (so some
    $\Theta\left(\sqrt{h}\right)$), then this estimator is observed to be
    multigrid convergent along digitization of smooth shapes. However,
    since the computation window is limited by the visibility, it
    better approximates the geometry near sharp or salient features.

    More precisely, we choose a Gaussian function
    $\Kernel{x}\coloneqq e^{-\frac{x^2}{2\sigma^2}}$ as a weight kernel. Let
    $V_p$ be the set of visible points from the point $p$. Let $c_p$
    be the weighted centroid of the visible points around $p$,
    i.e. $c_p \coloneqq \frac{\sum_{q \in V_p} \Kernel{\|q-p\|}q}{\sum_{q \in
    V_p} \Kernel{\|q-p\|}}$. We form the weighted covariance matrix
    $\mathcal{V}_p$ of the points $V_p$ as:
    \begin{equation}
        \mathcal{V}_p = \sum_{q \in V_p} \Kernel{\|q-p\|}(q - c_p)(q - c_p)^T.
    \end{equation}
    The \emph{visibility normal} $\vec{n}(p)$ of point $p$ at scale $\sigma$ is defined
    as the first eigenvector of the covariance matrix $\mathcal{V}_p$
    of the visible points, corresponding to its smallest
    eigenvalue. Its orientation is chosen so as to point in the same
    direction as the average of the trivial normals to the surfels
    touching the point $p$.


    \paragraph{Experimental validation.} [TO COMPLETE]
    Figure~\ref{fig:normals-estimation} shows an example
    of our normals compared to normals computed with the integral invariant (II) estimator~\cite{Lachaud:2017-lnm}.

    \begin{figure}
        \centering
        \begin{tabular}{|c||c|c|}
            \hline
            Normals & With cube edges & Flat (no shading) \\
            \hline
            \hline
            \raisebox{18mm}{II} &
            \includegraphics[width=0.3\textwidth]{pictures/cps-IIN-flat-edge} &
            \includegraphics[width=0.3\textwidth]{pictures/cps-IIN-flat} \\
            %% \includegraphics[width=0.4\textwidth]{pictures/chinese-dragon-normal-estimation-cubes-II} &
            %% \includegraphics[width=0.4\textwidth]{pictures/chinese-dragon-normal-estimation-smooth-II} \\
            \hline
            \raisebox{18mm}{Ours} &
            \includegraphics[width=0.3\textwidth]{pictures/cps-VN-flat-edge} &
            \includegraphics[width=0.3\textwidth]{pictures/cps-VN-flat} \\
            %% \includegraphics[width=0.4\textwidth]{pictures/chinese-dragon-normal-estimation-cubes-NV} &
            %% \includegraphics[width=0.4\textwidth]{pictures/chinese-dragon-normal-estimation-smooth-NV} \\
            \hline
            \raisebox{18mm}{II} &
            \includegraphics[width=0.43\textwidth]{pictures/tie256-IIN-flat-edge} &
            \includegraphics[width=0.43\textwidth]{pictures/tie256-IIN-flat} \\
            %% \includegraphics[width=0.4\textwidth]{pictures/octaflower-normal-estimation-cubes-II} &
            %% \includegraphics[width=0.4\textwidth]{pictures/octaflower-normal-estimation-smooth-II} \\
            \hline
            \raisebox{18mm}{Ours} &
            \includegraphics[width=0.43\textwidth]{pictures/tie256-VN-flat-edge} &
            \includegraphics[width=0.43\textwidth]{pictures/tie256-VN-flat} \\
            %% \includegraphics[width=0.4\textwidth]{pictures/octaflower-normal-estimation-cubes-NV} &
            %% \includegraphics[width=0.4\textwidth]{pictures/octaflower-normal-estimation-smooth-NV} \\
            \hline
        \end{tabular}
        \caption{Examples of normals computed on a cps, then on a
        tie as a color map. First set displays II normals, second set
        uses the visibility algorithm to compute them. The normals are colored
        according to their orientation as $0.5 \cdot (n_i + \mathbbm{1})$. The
        right images are the smooth version of the left images. ``Integral
        Invariant normals'' are computed using a radius of $r=4.5$, while
        our normal estimator are computed using a deviation of $\sigma=4$, and so
        a radius of $r=2\sigma=8$}
        \label{fig:normals-estimation}
    \end{figure}

    %% Then, to compute the curvatures, we use the Corrected Normal Current
    %% estimator~\cite{lachaud:2022-dcg} which are based on the normals computed
    %% above.

    \paragraph{Application to curvature estimation.}
    In order to illustrate better that the visibility normals better
    take into account the sharp features of a digital surface while
    staying meaningfull in digitization of smooth parts, we compare
    the curvature estimates induced by different discrete normal
    estimators. We exploit the \emph{Corrected Normal Current (CNC)
        estimator}, whose theory is detailed in~\cite{lachaud:2022-dcg}
    and which can estimate all kinds of curvatures given positions and
    normals. It produces state-of-the-art curvature estimates on
    polygonal surfaces~\cite{lachaud:2020-cgf}, point clouds~\cite{lachaud:2023-cgf}, and even outperforms Integral Invariant
    curvature estimates~\cite{coeurjolly:2014-cviu} on digital
    surfaces~\cite{lachaud:2022-dcg}. Its implementation is also
    available in    \href{https://dgtal-team.github.io/doc-nightly/moduleCurvatureMeasures.html}{\textsc{DGtal}}.

    Figure~\ref{fig:fig-curvatures} displays the results of CNC curvature
    estimations on the digitization of a piecewise smooth shape
    ``Talking D20'', taken from
    \href{https://ten-thousand-models.appspot.com/detail.html?file_id=1533028}{Thingi10K}.
    We compare the differences obtained by just changing the discrete
    normal estimator (available in the \textsc{DGtal} library):
    (column II normals) Integral Invariant normals with $r=6$, (column
    CTriv normals) convolved trivial normals with $r=6$, (column
    Visibility normals) our proposed estimator (VN) with $\sigma=4$ and
    maximal visibility distance $2\sigma$. These parameters were
    chosen so that the respective computation windows of the different
    estimators are approximately the same.

    The II estimator is good along digitization of smooth or flat parts of
    the dice, but presents curious artefacts near sharp features
    induced by the hollowed out numbers: this is due to the nature of
    II normal estimates, which computes a PCA of a ball centered on
    the point of interest and may include points on the other side of
    the saliencies.

    The CTriv estimator only performs averaging of trivial normal
    directions along the surface. It behaves much better than II near
    features (although it tends to smooth curvatures) since it does
    not use information from across the gap. However some oscillations
    of the curvatures are distinguishable especially along the flat
    parts, and some curvature estimates are erroneous on smoother
    parts (like the edge above 6 for $\kappa_2$ or several dice
    vertices).

    The VN estimator takes the best of the two previous approaches. It
    remains precise and stable on smooth and flat regions, while
    perfectly delineating sharp features and holes, whatever the kind
    of estimated curvatures. Its drawback is the computation time,
    which is $52s$ for a maximal visibility distance $8$, compared to
    $2.3$s for II and $0.1s$ for CTriv. Note that the computation time
    falls back to $33s$ for a maximal distance of $6$ (and same
    $\sigma=4$) while the result is visually indistinguishable. 


    \newcommand{\MyZoom}[1]{%
        \begin{tikzpicture}[spy using outlines={circle,magnification=1.8,size=2cm,connect spies}]
        \node[inner sep=0pt] {\pgfimage[width=0.3\textwidth]{#1}};
        \spy[overlay,blue] on (0.4,0.2) in node at (-0.8,0.8);
        \end{tikzpicture}}
    % \newcommand{\MyZoom}[1]{\includegraphics[width=0.3\textwidth]{#1}}

    \begin{figure}
        \begin{center}
            \begin{tabular}{|c||c|c|c|}
                \hline
                Curv. & II normals & CTriv normals & Our normals \\ \hline \hline
                \raisebox{18mm}{$\kappa_1$} &
                \MyZoom{pictures/d20-k1-II.jpg} &
                \MyZoom{pictures/d20-k1-CTriv.jpg}&
                \MyZoom{pictures/d20-k1-VN.jpg}\\ \hline
                \raisebox{18mm}{$\kappa_2$} &
                \MyZoom{pictures/d20-k2-II.jpg} &
                \MyZoom{pictures/d20-k2-CTriv.jpg}&
                \MyZoom{pictures/d20-k2-VN.jpg}\\ \hline
                \raisebox{18mm}{$H$} &
                \MyZoom{pictures/d20-H-II.jpg} &
                \MyZoom{pictures/d20-H-CTriv.jpg}&
                \MyZoom{pictures/d20-H-VN.jpg}\\ \hline
                \raisebox{18mm}{$G$} &
                \MyZoom{pictures/d20-G-II.jpg} &
                \MyZoom{pictures/d20-G-CTriv.jpg}&
                \MyZoom{pictures/d20-G-VN.jpg}\\ \hline
            \end{tabular}
        \end{center}
        \caption{\label{fig:fig-curvatures}Estimation of curvatures using
          Corrected Normal Current estimators \cite{lachaud:2022-dcg}
          with a measure of radius $2$ for the shape ``Dice-20'' of
          Thingi10K database at resolution $256^3$. This estimator is
          parameterized by an input normal estimator: first column by
          ``Integral Invariant normals'' (radius $r=6$), second column
          by ``Convolved Trivial normals'' (radius $k=6$), third
          column by our presented normal estimator (deviation
          $\sigma=4$, radius $r=2\sigma=8$). Per row are displayed the
          estimated curvatures in order: first and second principal
          curvatures $\kappa_1$ and $\kappa_2$, mean curvature $H$,
          Gaussian curvature $G$. The range of curvature between deep
          blue and deep red is $\lbrack -0.1, 0.1 \rbrack$ with white
          color equal to $0$.}
    \end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \section{Conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{credits}
        \subsubsection{\ackname}
        This work is partially supported by the French National Research Agency
        within the StableProxies project (ANR-22-CE46-0006).
%% \subsubsection{\discintname}
%% It is now necessary to declare any competing interests or to specifically
%% state that the authors have no competing interests. Please place the
%% statement with a bold run-in heading in small font size beneath the
%% (optional) acknowledgments\footnote{If EquinOCS, our proceedings submission
%% system, is used, then the disclaimer can be provided directly in the system.},
%% for example: The authors have no competing interests to declare that are
%% relevant to the content of this article. Or: Author A has received research
%% grants from Company W. Author B has received a speaker honorarium from
%% Company X and owns stock in Company Y. Author C is a member of committee Z.
    \end{credits}
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
    \bibliographystyle{splncs04}
    \bibliography{biblio}

\end{document}
