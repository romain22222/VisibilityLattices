As said in the introduction, any cell of $\mathcal{C}$ can be
characterized as a point with integer coordinates, aka \emph{lattice
point}. For instance, a standard way is to double the coordinates of
the centroid of the cell (often called its Khalimsky code). Now we
have to represent an arbitrary set $K$ of lattice points.

Let $(\ve_j)_{j=1,\dots}$ be the canonical basis of $\Z^d$.  We may
choose an arbitrary projection \emph{axis} $j \in
\{1,\ldots,d\}$. Letting $\pi_j$ be the projector along this axis, we
can collect all the cells of $K$ that projects onto the same
points. Let $p \in K$. Then $\pi^{-1}_j(p)$ is a set of cells having
all the same coordinates except along coordinate $j$. This set can be
ordered increasingly and stored as a list of integer intervals (see
Fig.~\ref{fig:lattice-representation} for an illustration).

A \emph{sequence of intervals} is an ordered list of intervals $L =
([a_i,b_i])_{i=1,\ldots,n}$ such that $a_i \in \Z, b_i \in \Z, b_i + 1
< a_{i+1}$, i.e., disjoint intervals with at least a missing
integer. We denote by $\mathbb{L}$ the set of sequences of
intervals. An integer $k$ belongs to $L$ iff $\exists i$ such that
$a_i \Le k \Le b_i$. For a finite set of integers, there is a unique
sequence of intervals representing it.

A \emph{lattice map along axis $j$} is a set of pairs $(q,L_q)$, with
$q \in \Z^{d-1}$ and $L_q \in \mathbb{L}$. The lattice map $M_K$
\emph{represents} $K$ when, for any point $p \in K$, the pair
$(\pi_j(p), L_{\pi_j(p)})$ exists in $M_K$ and $p_j \in L_{\pi_j(p)}$,
with $p_j$ the $j$-th coordinate of $p$, and reciprocally, $\forall
(q,L_q) \in M_K, \forall i \in L_q, q+i\ve_j \in K$.


To improve computation time, we will use lattice maps of integer
intervals.

\begin{definition}
  A sequence of intervals is an ordered list of intervals $L = ([a_i,b_i])_{i=1,\ldots,n}$ such that $b_i + 1 < a_{i+1}$, i.e., disjoint intervals with at least a missing integer.
\end{definition}

\begin{definition}
  A translation of an interval $A$ is defined as $A+t \coloneqq [a+t, b+t]$
\end{definition}

\begin{definition}
  A translation of a sequence of intervals $L$ is the sequence defined as $L+t \coloneqq \{L_1+t,\ldots,L_n+t\}$
\end{definition}

\begin{definition}
  All translations $T$ of an interval or a sequence of intervals $A$ in a sequence of intervals $L$ are defined as $ T \coloneqq \{ t, st. A+t \subset L\}$
\end{definition}

We will consider lattice maps as pairs of (shift, intervals), where shifts are points $p \in \R^{d-1}$. All coordinates are doubled, so that the represented cell $\forall c \in \R^d$ will have a dimension equal to $\sum_{i=1}^d \left(c[i]\mod d\right)$.
In figure~\ref{fig:lattice-representation}, we display a representation of lattice maps applied to a 2-d cell complex where all coordinates are already doubled. Note that the examples are in 2-d, the shown results are in 3-d and the algorithm is for n-d.

\begin{figure}
  \centering
  \input{lattice.tikz}
  \caption{\label{fig:lattice-representation} Representation of a
    2d cell complex (here the star of a given curve) as a lattice
    map. From 65 cells (with two coordinates) on the left, we get 11
    intervals on the right.}
\end{figure}

\begin{figure}
  \centering
  \input{algorithm.tikz}
  \caption{Evolution of the visibility check algorithm for a $(2,1)$
    vector. Green is the vector lattice map, black is the figure
    lattice map, red are the current intervals of positions where
    the visibility is still possible. The last red intervals are
    the visible positions. We travel the lattice maps from
    bottom-up and the found visibilities are drawn on the
    uppest figure.}
  \label{fig:visibility-algorithm-evolution}
\end{figure}

\begin{algorithm}
  \caption{Given a subcomplex $C$ and an integer $r$, returns the visibility from every point of $C$ up to distance $r$. The main axis is supposed to be $z$, while $x,y$ are the auxiliary axes.}
  \label{alg:visibility}
  \begin{algorithmic}
    \Function{Visibility}{$C$: Subcomplex, $r$: Integer}
    \State $\Omega \gets \Call{Star}{C}$ \Comment{Lattice map of the star of the studied cell complex}
    \State $Directions \gets \Call{GetAllPrimalDirections}{r}$
    \State $V: \text{vector of boolean} \gets [0, \ldots, 0]$ \Comment{length $Size(Directions) \times \#C.pointels$}
    \State $low, high \gets \Call{BoundingBoxZ}{\Omega}$
    \ForAll{$d$ in $Directions$}
    \ForAll{shift $S$ in $\Omega$}
    \State $R \gets [low, high]$
    \ForAll{pair $P$ in $\Call{Star}{\text{d}}$}
    \State $R \gets R \cap \Call{Translations}{P.intervals,\Omega[S + P.shift]}$
    \EndFor
    \State \Call{UpdateVisibility}{$V$, $R$}
    \EndFor
    \EndFor
    \State \Return $V$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

In order to compute the visibility, we first compute $\Omega = \text{Star}(C)$. Then for each primal direction of
coordinates at most $r$, we look at all the possible positions this specific direction does link 2 visible points
of the cell complex. In order to do so, for each shift in $\Omega$, we compute the positions where points are
visible using the same method as presented in~\ref{fig:visibility-algorithm-evolution}. Some results of visible
points are present in figure~\ref{fig:visibility-results}.

\begin{algorithm}
  \caption{Given 2 lists of integer intervals $K$ and $L$, returns $K \cap L$}
  \label{alg:intersection}
  \begin{algorithmic}
    \Function{Intersection ($\cap$)}{\text{K, L}: Intervals}
    \State $R \gets \emptyset$; $k \gets 0$; $l \gets 0$;
    \While{$k < K.nbIntervals \And l < L.nbIntervals$}
    \State $[a,b] \gets K[k]$; $[c,d] \gets L[l]$
    \State $e \gets \max(a, c)$; $f \gets \min(b, d)$;
    \If{$e \leq f$}
    $R.append([e, f])$;
    \EndIf
    \If{$b \leq d$}
    $k \gets k+1$;
    \EndIf
    \If{$d \leq b$}
    $l \gets l+1$;
    \EndIf
    \EndWhile
    \State \Return $R$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

To efficiently compute the intersection of 2 lists of intervals $K$ and $L$, we go through the first 2 unvisited
elements of the 2 lists. If they don't overlap (i.e.\ the start and end of the 1st interval are both smaller than
the start of the other), then we can discard the smaller interval. Else, we construct the intersection of these
2 intervals as one of the resulting intervals. We then can skip the interval with the smallest end. If both
intervals have the same end, then both intervals can be skipped. Doing this computation until one of the lists
is empty returns the intersection of both lists of intervals.

% Insert visibility results images

\begin{figure}
  \centering
  \begin{tabular}{c c}
    \includegraphics[width=0.4\textwidth]{pictures/visibility_from_given_point_r_10} &
    \includegraphics[width=0.4\textwidth]{pictures/visibility_aware_of_features}
  \end{tabular}
  \caption{Examples of visibility on a fandisk and a torus knot. First one is on the edge
    of a fandisk, where the visibility stops at the edges. The other one is in the interior
    of a torus knot, where we can see that the visibility is feature-aware and doesn't see
    the other side of the torus' branch.}
  \label{fig:visibility-results}
\end{figure}
%
%    \begin{figure}
%        \begin{center}
%            \includegraphics[width=0.8\textwidth]{pictures/visibility_from_given_point_r_10}
%            \caption{Visibility of a point on an edge of a fandisk}
%            \label{fig:visibility-fandisk}
%        \end{center}
%    \end{figure}
%    \begin{figure}
%        \begin{center}
%            \includegraphics[width=0.8\textwidth]{pictures/visibility_aware_of_features}
%            \caption{Visibility of a point on a torus knot (the visibility is feature-aware)}
%            \label{fig:visibility-torus-knot}
%        \end{center}
%    \end{figure}


% Quantitative results

\begin{figure}
  \begin{tikzpicture}
    \centering
    \begin{axis}[
        width=0.8\textwidth,
        legend columns=3,
        xlabel={Gridstep},
        ylabel={Mean distance},
        x dir=reverse,
        legend pos=north west,
        ymajorgrids=true,
        grid style=dashed,
        ymax=70,
        ymode=log,
        xmode=log,
        log ticks with fixed point,
      ]

      \addplot[
        color=cyan,
      ] coordinates {
        (0.0625,7.61948)(0.125,5.49755)(0.25,3.97418)(0.375,3.00921)(0.5,2.85702)(0.625,2.34448)(0.75,1.85023)(0.875,2.16868)(1.0,1.85023)
      };
      \addlegendentry{sphere1}
      \addplot[
        color=red,
      ] coordinates {
        (0.0625,38.1045)(0.125,26.8765)(0.25,19.6747)(0.375,16.6192)(0.5,14.0867)(0.625,12.5062)(0.75,11.3734)(0.875,10.2845)(1,8.90781)
      };
      \addlegendentry{goursat}
      \addplot[
        color=violet,
      ] coordinates {
        (0.0625,25.5024)(0.125,18.2364)(0.25,12.3975)(0.375,9.41303)(0.5,8.69558)(0.625,7.37667)(0.75,6.82131)(0.875,6.05735)(1,6.33877)
      };
      \addlegendentry{torus}
      \addplot[
        color=MyGreen,
      ] coordinates {
        (0.0625,27.9287)(0.125,17.5104)(0.25,10.8007)(0.375,8.69514)(0.5,7.26074)(0.625,6.2309)(0.75,5.6897)(0.875,5.28197)(1,4.96098)
      };
      \addlegendentry{leopold}
      \addplot[
        color=yellow!80!black,
      ] coordinates {
        (0.0625,41.9816)(0.125,27.7104)(0.25,18.2339)(0.375,14.6475)(0.5,12.3618)(0.625,9.55647)(0.75,9.83208)(0.875,7.51861)(1,7.99732)
      };
      \addlegendentry{rcube}
      \addplot [
        color=black,
        thick,
        domain=0.0625:1,
        samples=100,
      ] {x^(-0.5)};
      \addlegendentry{$\sqrt{h}=\sqrt{\frac{1}{x}}$}
    \end{axis}
  \end{tikzpicture}
  \caption{Mean Visibility Distance as a Function of Grid Resolution}
  \label{fig:meanvisibility-gridstep}
\end{figure}

\begin{figure}[t]
  \input{pointelscomptime.tikz}
  \caption{Computation Time of Visibility as a Function of pointels amount. We compare the computation time of
    the naive breadth first visibility algorithm against our version using intervals. We input the same radius to
    both versions (10, 20, 30) and test it on 6 different figures (goursat, torus, rcube, sphere9, leopold, d20)
    with various gridsteps, giving us figures with pointel amounts ranging from 520 to 390235.}
  \label{fig:meanvisibility-computationComplexity}
\end{figure}
